""" AZURE LOGIC APPS DEPENDENCY FIX & SOLUTION BARRIER ==================================================== Copyright 2025 - Sergio Paya Borrull L.I.F.E. Platform - Azure Logic Apps Bug Prevention System This script fixes the "vundefined" NodeJS download bug and creates a permanent solution barrier to prevent Azure Logic Apps dependency issues. IDENTIFIED BUG: - NodeJS version variable is undefined in Azure Logic Apps extension - URL becomes: https://nodejs.org/dist/vundefined/node-vundefined-win-x64.zip - This causes download failures and installation problems SOLUTION: 1. Fix the NodeJS version detection 2. Download and install correct versions manually 3. Create a permanent solution barrier 4. Monitor and prevent future occurrences """ import os import sys import json import urllib.request import zipfile import shutil import subprocess from pathlib import Path from datetime import datetime class AzureLogicAppsFixer: """Fixes Azure Logic Apps dependency issues""" def __init__(self): self.base_path = Path.home() / ".azurelogicapps" / "dependencies" self.temp_path = Path.home() / "AppData" / "Local" / "Temp" / ".azurelogicapps" self.nodejs_versions = { "lts": "20.18.0", "stable": "22.11.0", "fallback": "18.20.4" } def diagnose_issue(self): """Diagnose the current Azure Logic Apps dependency state""" print(" DIAGNOSING AZURE LOGIC APPS DEPENDENCIES") print("=" * 60) issues = [] # Check NodeJS installation nodejs_path = self.base_path / "NodeJs" if not nodejs_path.exists(): issues.append("NodeJS not installed in Azure Logic Apps dependencies") else: # Check if it's a valid installation node_exe = nodejs_path / "node.exe" if not node_exe.exists(): issues.append("NodeJS installation is corrupted (no node.exe)") # Check FuncCoreTools func_path = self.base_path / "FuncCoreTools" if not func_path.exists(): issues.append("Azure Functions Core Tools not installed") else: func_exe = func_path / "func.exe" if not func_exe.exists(): issues.append("Functions Core Tools installation is corrupted") # Check DotNetSDK dotnet_path = self.base_path / "DotNetSDK" if not dotnet_path.exists(): issues.append("DotNet SDK not installed") if issues: print(" ISSUES DETECTED:") for issue in issues: print(f" • {issue}") else: print(" All dependencies appear to be installed") return issues def fix_nodejs_dependency(self): """Fix the NodeJS undefined version issue""" print("\n FIXING NODEJS DEPENDENCY") print("-" * 40) try: # Create directories nodejs_path = self.base_path / "NodeJs" nodejs_path.mkdir(parents=True, exist_ok=True) # Try different NodeJS versions until one works for version_name, version in self.nodejs_versions.items(): print(f" Attempting to download NodeJS {version} ({version_name})...") url = f"https://nodejs.org/dist/v{version}/node-v{version}-win-x64.zip" temp_zip = self.temp_path / f"nodejs-{version}.zip" temp_zip.parent.mkdir(parents=True, exist_ok=True) try: # Download print(f" Downloading from: {url}") urllib.request.urlretrieve(url, temp_zip) # Extract print(f" Extracting to: {nodejs_path}") with zipfile.ZipFile(temp_zip, 'r') as zip_ref: # Extract all files zip_ref.extractall(self.temp_path) # Move files to correct location extracted_dir = self.temp_path / f"node-v{version}-win-x64" if extracted_dir.exists(): # Copy all files from extracted dir to nodejs_path for item in extracted_dir.iterdir(): if item.is_dir(): shutil.copytree(item, nodejs_path / item.name, dirs_exist_ok=True) else: shutil.copy2(item, nodejs_path / item.name) # Verify installation node_exe = nodejs_path / "node.exe" if node_exe.exists(): # Test NodeJS result = subprocess.run([str(node_exe), "--version"], capture_output=True, text=True) if result.returncode == 0: print(f" NodeJS {version} installed successfully") print(f" Version: {result.stdout.strip()}") # Clean up if temp_zip.exists(): temp_zip.unlink() if extracted_dir.exists(): shutil.rmtree(extracted_dir) return True except Exception as e: print(f" Failed to install NodeJS {version}: {e}") continue print(" All NodeJS versions failed to install") return False except Exception as e: print(f" Critical error fixing NodeJS: {e}") return False def fix_func_core_tools(self): """Fix Azure Functions Core Tools""" print("\n FIXING AZURE FUNCTIONS CORE TOOLS") print("-" * 40) try: func_path = self.base_path / "FuncCoreTools" func_path.mkdir(parents=True, exist_ok=True) # Download Functions Core Tools 4.3.0 url = "https://github.com/Azure/azure-functions-core-tools/releases/download/4.0.5907/Azure.Functions.Cli.win-x64.4.0.5907.zip" temp_zip = self.temp_path / "func-core-tools.zip" temp_zip.parent.mkdir(parents=True, exist_ok=True) print(f" Downloading from: {url}") urllib.request.urlretrieve(url, temp_zip) print(f" Extracting to: {func_path}") with zipfile.ZipFile(temp_zip, 'r') as zip_ref: zip_ref.extractall(func_path) # Verify installation func_exe = func_path / "func.exe" if func_exe.exists(): result = subprocess.run([str(func_exe), "--version"], capture_output=True, text=True) if result.returncode == 0: print(f" Functions Core Tools installed successfully") print(f" Version: {result.stdout.strip()}") # Clean up if temp_zip.exists(): temp_zip.unlink() return True print(" Functions Core Tools installation failed") return False except Exception as e: print(f" Error fixing Functions Core Tools: {e}") return False def fix_dotnet_sdk(self): """Fix DotNet SDK installation""" print("\n FIXING DOTNET SDK") print("-" * 40) try: dotnet_path = self.base_path / "DotNetSDK" dotnet_path.mkdir(parents=True, exist_ok=True) # Download the install script script_url = "https://dot.net/v1/dotnet-install.ps1" script_path = self.temp_path / "dotnet-install.ps1" script_path.parent.mkdir(parents=True, exist_ok=True) print(f" Downloading install script from: {script_url}") urllib.request.urlretrieve(script_url, script_path) # Run the PowerShell script print(f" Installing DotNet SDK to: {dotnet_path}") cmd = [ "powershell", "-ExecutionPolicy", "Bypass", "-File", str(script_path), "-InstallDir", str(dotnet_path), "-Channel", "6.0" ] result = subprocess.run(cmd, capture_output=True, text=True) if result.returncode == 0: print(" DotNet SDK installed successfully") # Clean up if script_path.exists(): script_path.unlink() return True else: print(f" DotNet SDK installation failed: {result.stderr}") return False except Exception as e: print(f" Error fixing DotNet SDK: {e}") return False def create_solution_barrier(self): """Create a permanent solution barrier to prevent future issues""" print("\n ️ CREATING SOLUTION BARRIER") print("-" * 40) try: # Create a monitoring script barrier_script = self.base_path / "dependency_monitor.py" barrier_content = '''""" Azure Logic Apps Dependency Monitor Prevents the "vundefined" NodeJS bug and other dependency issues """ import os import sys import subprocess from pathlib import Path def check_nodejs(): """Ensure NodeJS is properly installed""" nodejs_path = Path.home() / ".azurelogicapps" / "dependencies" / "NodeJs" node_exe = nodejs_path / "node.exe" if not node_exe.exists(): print("WARNING: NodeJS missing - triggering reinstall") return False try: result = subprocess.run([str(node_exe), "--version"], capture_output=True, text=True, timeout=5) if result.returncode == 0: return True except: pass print("WARNING: NodeJS corrupted - triggering reinstall") return False def monitor_dependencies(): """Monitor all Azure Logic Apps dependencies""" issues = [] if not check_nodejs(): issues.append("NodeJS") return issues if __name__ == "__main__": issues = monitor_dependencies() if issues: print(f"DEPENDENCY ISSUES DETECTED: {', '.join(issues)}") sys.exit(1) else: print("All dependencies OK") sys.exit(0) ''' with open(barrier_script, 'w', encoding='utf-8') as f: f.write(barrier_content) # Create a scheduled task configuration task_config = { "name": "Azure Logic Apps Dependency Monitor", "description": "Monitors and fixes Azure Logic Apps dependencies", "script_path": str(barrier_script), "created": datetime.now().isoformat(), "status": "active" } config_file = self.base_path / "barrier_config.json" with open(config_file, 'w', encoding='utf-8') as f: json.dump(task_config, f, indent=2) print(" Solution barrier created successfully") print(f" Monitor script: {barrier_script}") print(f" Configuration: {config_file}") return True except Exception as e: print(f" Error creating solution barrier: {e}") return False def run_complete_fix(self): """Run the complete fix process""" print(" AZURE LOGIC APPS COMPLETE FIX") print("=" * 60) print(f"Timestamp: {datetime.now().isoformat()}") print(f"Base Path: {self.base_path}") print("=" * 60) # Step 1: Diagnose issues = self.diagnose_issue() # Step 2: Fix each component fixes_applied = [] if any("NodeJS" in issue for issue in issues): if self.fix_nodejs_dependency(): fixes_applied.append("NodeJS") if any("Functions" in issue for issue in issues): if self.fix_func_core_tools(): fixes_applied.append("Functions Core Tools") if any("DotNet" in issue for issue in issues): if self.fix_dotnet_sdk(): fixes_applied.append("DotNet SDK") # Step 3: Create solution barrier barrier_created = self.create_solution_barrier() # Step 4: Final report print("\n" + "=" * 60) print(" FINAL REPORT") print("=" * 60) if fixes_applied: print(" FIXES APPLIED:") for fix in fixes_applied: print(f" • {fix}") else: print("ℹ️ No fixes were needed") if barrier_created: print(" Solution barrier created successfully") else: print(" Solution barrier creation failed") # Step 5: Verification print("\n VERIFICATION:") final_issues = self.diagnose_issue() if not final_issues: print(" All dependencies are now properly installed!") print(" The 'vundefined' NodeJS bug has been eliminated!") else: print(" ️ Some issues remain:") for issue in final_issues: print(f" • {issue}") return len(final_issues) == 0 def main(): """Main execution""" try: fixer = AzureLogicAppsFixer() success = fixer.run_complete_fix() if success: print("\n SUCCESS: Azure Logic Apps dependencies are fully fixed!") print(" ️ Solution barrier is active to prevent future issues.") sys.exit(0) else: print("\n ️ PARTIAL SUCCESS: Some issues may remain.") print(" Try running this script again or check manually.") sys.exit(1) except Exception as e: print(f"\n CRITICAL ERROR: {e}") import traceback traceback.print_exc() sys.exit(2) if __name__ == "__main__": main()