# usr/bin/env python3 """ PROFESSIONAL REPOSITORY SANITIZER Removes all emojis and converts repository to professional, clinical tone Copyright 2025 - Sergio Paya Borrull L.I.F.E. Platform Professional Standards Implementation """ import os import re import sys import unicodedata import json from pathlib import Path from typing import List, Dict, Tuple class RepositoryProfessionalizer: """ Comprehensive repository professionalization tool. Removes emojis, converts casual language to clinical tone, and ensures enterprise-ready documentation standards. """ def __init__(self, repo_path: str = "."): self.repo_path = Path(repo_path).resolve() self.processed_files = [] self.emoji_count = 0 self.files_modified = 0 # Professional language replacements self.professional_replacements = { # Casual to Professional " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ️": "", " ️": "", " ️": "", " ️": "", " ": "", " ": "", " ️": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ️": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", " ": "", # Casual phrases to professional "Excellent": "Excellent", "Noteworthy": "Noteworthy", "Exceptional": "Exceptional", "Highly": "Highly", "Comprehensive": "Comprehensive", "Outstanding": "Outstanding", "Excellent": "Excellent", "Complete": "Complete", "Successful": "Successful", "Satisfactory": "Satisfactory", "Optimal": "Optimal", "Complete": "Complete", "Executed": "Executed", "Notable": "Notable", "Success": "Success", "Achievement": "Achievement", "Completion": "Completion", "Success": "Success", "Optimal result": "Optimal result", "Leading solution": "Leading solution", # Platform naming standardization "L.I.F.E Platform ": "L.I.F.E Platform", "L.I.F.E Platform ": "L.I.F.E Platform", "L.I.F.E. Platform ": "L.I.F.E Platform", "L.I.F.E. Platform ": "L.I.F.E Platform", } # Files to process (extensions) self.target_extensions = { '.md', '.txt', '.py', '.js', '.html', '.css', '.json', '.yml', '.yaml', '.xml', '.bat', '.ps1', '.sh', '.rst', '.cfg', '.ini', '.toml', '.dockerfile', '.gitignore' } # Files to skip self.skip_patterns = { '.git/', '__pycache__/', 'node_modules/', '.venv/', 'venv/', '.env', '.pytest_cache/', '.coverage', 'dist/', 'build/', '*.egg-info/', '.DS_Store', 'thumbs.db', '*.log', '*.tmp', '*.temp' } def is_emoji(self, char: str) -> bool: """Check if a character is an emoji using Unicode categories.""" try: return unicodedata.category(char) == 'So' or \ ord(char) in range(0x1F600, 0x1F64F) or \ ord(char) in range(0x1F300, 0x1F5FF) or \ ord(char) in range(0x1F680, 0x1F6FF) or \ ord(char) in range(0x2600, 0x26FF) or \ ord(char) in range(0x2700, 0x27BF) or \ ord(char) in range(0x1F900, 0x1F9FF) or \ ord(char) in range(0x1F1E0, 0x1F1FF) except (ValueError, OverflowError): return False def remove_emojis(self, text: str) -> str: """Remove all emojis from text.""" result = "" emoji_removed = 0 for char in text: if self.is_emoji(char): emoji_removed += 1 self.emoji_count += 1 # Replace with space to avoid word concatenation if result and result[-1] != ' ': result += " " else: result += char # Clean up multiple spaces result = re.sub(r'\s+', ' ', result) return result.strip() def professionalize_content(self, content: str) -> str: """Apply professional language transformations.""" # Remove emojis first content = self.remove_emojis(content) # Apply professional replacements for casual, professional in self.professional_replacements.items(): content = content.replace(casual, professional) # Clean up markdown headers with emojis content = re.sub(r'^(#{1,6})\s*[^\w\s]*\s*([^#\n]+)', r'\1 \2', content, flags=re.MULTILINE) # Clean up multiple spaces and empty lines content = re.sub(r'[ \t]+', ' ', content) content = re.sub(r'\n\s*\n\s*\n', '\n\n', content) # Remove emoji-only lines lines = content.split('\n') cleaned_lines = [] for line in lines: stripped = line.strip() if stripped and not all(self.is_emoji(c) or c.isspace() for c in stripped): cleaned_lines.append(line) elif not stripped: # Keep empty lines for formatting cleaned_lines.append(line) return '\n'.join(cleaned_lines) def should_skip_file(self, file_path: Path) -> bool: """Check if file should be skipped.""" file_str = str(file_path) for pattern in self.skip_patterns: if pattern in file_str: return True # Skip binary files if file_path.suffix.lower() in {'.exe', '.dll', '.so', '.dylib', '.bin', '.img', '.iso'}: return True # Skip image/media files if file_path.suffix.lower() in {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.mp4', '.avi', '.mov', '.mp3', '.wav', '.pdf'}: return True return False def process_file(self, file_path: Path) -> bool: """Process a single file for professionalization.""" if self.should_skip_file(file_path): return False if file_path.suffix.lower() not in self.target_extensions: return False try: # Read file with encoding detection encodings = ['utf-8', 'utf-16', 'latin-1', 'cp1252'] content = None encoding_used = None for encoding in encodings: try: with open(file_path, 'r', encoding=encoding) as f: content = f.read() encoding_used = encoding break except (UnicodeDecodeError, UnicodeError): continue if content is None: print(f" ️ Could not read file: {file_path}") return False # Process content original_content = content processed_content = self.professionalize_content(content) # Only write if content changed if processed_content != original_content: with open(file_path, 'w', encoding='utf-8') as f: f.write(processed_content) self.processed_files.append(str(file_path)) self.files_modified += 1 return True return False except Exception as e: print(f" Error processing {file_path}: {str(e)}") return False def process_repository(self) -> Dict[str, any]: """Process entire repository for professionalization.""" print("=" * 60) print("L.I.F.E PLATFORM PROFESSIONAL REPOSITORY SANITIZER") print("Removing emojis and converting to clinical tone") print("=" * 60) print() results = { 'files_processed': 0, 'files_modified': 0, 'emojis_removed': 0, 'modified_files': [], 'errors': [] } # Process all files recursively for root, dirs, files in os.walk(self.repo_path): # Skip certain directories dirs[:] = [d for d in dirs if not any(pattern.rstrip('/') in d for pattern in self.skip_patterns)] for file in files: file_path = Path(root) / file results['files_processed'] += 1 if self.process_file(file_path): print(f" Professionalized: {file_path.relative_to(self.repo_path)}") results['modified_files'].append(str(file_path.relative_to(self.repo_path))) # Update results results['files_modified'] = self.files_modified results['emojis_removed'] = self.emoji_count # Generate report print() print("=" * 60) print("PROFESSIONALIZATION COMPLETE") print("=" * 60) print(f"Files Processed: {results['files_processed']}") print(f"Files Modified: {results['files_modified']}") print(f"Emojis Removed: {results['emojis_removed']}") print() if results['modified_files']: print("Modified Files:") for file in results['modified_files']: print(f" • {file}") else: print("No files required modification.") # Save report report_path = self.repo_path / 'PROFESSIONALIZATION_REPORT.json' try: with open(report_path, 'w', encoding='utf-8') as f: json.dump(results, f, indent=2, ensure_ascii=False) print(f"\n Report saved: {report_path}") except Exception as e: print(f" ️ Could not save report: {e}") return results def create_professional_guidelines(self): """Create professional documentation guidelines.""" guidelines_content = """# L.I.F.E Platform Professional Documentation Standards ## Overview This document establishes professional documentation standards for the L.I.F.E Platform repository to ensure clinical, academic, and enterprise-grade presentation. ## Professional Language Standards ### Approved Terminology - Use "L.I.F.E Platform" consistently (no emojis) - Prefer "system," "platform," or "solution" over casual terms - Use "implementation" instead of "setup" or "config" - Use "analysis" instead of "check" or "test" ### Prohibited Elements - All Unicode emoji characters ( , , , etc.) - Casual exclamations ("Excellent", "Noteworthy", "Exceptional!") - Informal language ("super," "epic," "fantastic") - Non-professional symbols in headings ### Clinical Tone Guidelines - Use third-person, objective language - Emphasize evidence-based statements - Include specific metrics and measurements - Reference regulatory standards when applicable ## File Organization Standards ### Naming Conventions - Use descriptive, professional filenames - Avoid emojis or special characters in filenames - Use underscores or hyphens for word separation - Include version numbers for documentation ### Documentation Structure - Executive Summary (system overview) - Technical Specifications (detailed implementation) - Deployment Guidelines (installation procedures) - Validation Results (performance metrics) - Support Information (contact and resources) ## Compliance Requirements ### Clinical Applications - HIPAA compliance statements - FDA validation references - Security and privacy protocols - Audit trail documentation ### Enterprise Integration - SOC2 Type II compliance - GDPR data protection - Enterprise security frameworks - Professional service level agreements ## Implementation Checklist - [ ] Remove all emoji characters from documentation - [ ] Convert casual language to professional terminology - [ ] Standardize file naming conventions - [ ] Ensure clinical tone throughout - [ ] Include regulatory compliance statements - [ ] Add professional contact information - [ ] Validate technical accuracy of claims ## Maintenance Protocol 1. Regular documentation review (monthly) 2. Professional language validation 3. Compliance requirement updates 4. Technical accuracy verification 5. Enterprise presentation standards --- *This document serves as the definitive guide for maintaining professional standards across all L.I.F.E Platform documentation and code repositories.* """ guidelines_path = self.repo_path / 'PROFESSIONAL_DOCUMENTATION_STANDARDS.md' try: with open(guidelines_path, 'w', encoding='utf-8') as f: f.write(guidelines_content) print(f" Professional guidelines created: {guidelines_path}") except Exception as e: print(f" ️ Could not create guidelines: {e}") def main(): """Main execution function.""" import argparse parser = argparse.ArgumentParser( description="L.I.F.E Platform Professional Repository Sanitizer" ) parser.add_argument( '--repo-path', '-p', default='.', help='Path to repository (default: current directory)' ) parser.add_argument( '--create-guidelines', '-g', action='store_true', help='Create professional documentation guidelines' ) args = parser.parse_args() # Initialize professionalizer professionalizer = RepositoryProfessionalizer(args.repo_path) # Process repository results = professionalizer.process_repository() # Create guidelines if requested if args.create_guidelines: professionalizer.create_professional_guidelines() # Exit with appropriate code if results['files_modified'] > 0: print("\n Repository professionalization completed successfully!") sys.exit(0) else: print("\n Repository already meets professional standards!") sys.exit(0) if __name__ == '__main__': main()