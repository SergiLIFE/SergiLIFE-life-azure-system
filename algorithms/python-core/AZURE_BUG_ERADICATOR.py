""" AZURE BUG ERADICATOR - Complete System Repair Tool ===================================================== Copyright 2025 - Sergio Paya Borrull L.I.F.E. Platform Bug Elimination System This tool automatically detects and fixes ALL persistent bugs in your Azure apps: - Path and directory issues (Windows compatibility) - Import and dependency errors - Azure configuration problems - Environment variable issues - File encoding problems - Runtime errors Usage: python AZURE_BUG_ERADICATOR.py """ import os import sys import json import subprocess import re try: from pathlib import Path except ImportError as e: print(f'Warning: {e}') pass from typing import List, Dict, Tuple from dataclasses import dataclass from enum import Enum # ============================================================================ # BUG DETECTION SYSTEM # ============================================================================ class BugSeverity(Enum): CRITICAL = "CRITICAL" HIGH = "HIGH" MEDIUM = "MEDIUM" LOW = "LOW" class BugCategory(Enum): PATH_ISSUE = "Path/Directory Issue" IMPORT_ERROR = "Import Error" AZURE_CONFIG = "Azure Configuration" ENVIRONMENT = "Environment Variable" ENCODING = "File Encoding" RUNTIME = "Runtime Error" DEPENDENCY = "Dependency Missing" @dataclass class Bug: """Represents a detected bug""" category: BugCategory severity: BugSeverity file_path: str line_number: int description: str suggested_fix: str auto_fixable: bool = True class BugDetector: """Scans codebase for bugs""" def __init__(self, root_dir: str): self.root_dir = Path(root_dir) self.bugs: List[Bug] = [] def scan_all(self) -> List[Bug]: """Run all bug detection methods""" print(" Scanning for bugs...") self._detect_path_issues() self._detect_import_errors() self._detect_azure_config_issues() self._detect_environment_issues() self._detect_encoding_issues() print(f" Scan complete. Found {len(self.bugs)} bugs.") return self.bugs def _detect_path_issues(self): """Detect Windows path compatibility issues""" print(" → Checking path issues...") for py_file in self.root_dir.rglob("*.py"): try: with open(py_file, 'r', encoding='utf-8') as f: lines = f.readlines() for i, line in enumerate(lines, 1): # Check for problematic path operations if "Path(__file__).parent /" in line: self.bugs.append(Bug( category=BugCategory.PATH_ISSUE, severity=BugSeverity.CRITICAL, file_path=str(py_file), line_number=i, description=f"Incompatible path operation using Path() / operator on Windows", suggested_fix="Use os.path.join() or Path().joinpath() instead" )) # Check for .mkdir() without proper error handling if ".mkdir(" in line and "try:" not in lines[max(0, i-3):i]: self.bugs.append(Bug( category=BugCategory.PATH_ISSUE, severity=BugSeverity.HIGH, file_path=str(py_file), line_number=i, description="Directory creation without error handling", suggested_fix="Wrap in try-except or use os.makedirs(path, exist_ok=True)" )) # Check for hardcoded forward slashes if re.search(r'["\'].*\/.*\/.*["\']', line) and "http" not in line.lower(): self.bugs.append(Bug( category=BugCategory.PATH_ISSUE, severity=BugSeverity.MEDIUM, file_path=str(py_file), line_number=i, description="Hardcoded forward slashes in path (not Windows-compatible)", suggested_fix="Use os.path.join() or Path() for cross-platform compatibility" )) except Exception as e: print(f" ️ Could not scan {py_file}: {e}") def _detect_import_errors(self): """Detect missing or problematic imports""" print(" → Checking import errors...") for py_file in self.root_dir.rglob("*.py"): try: with open(py_file, 'r', encoding='utf-8') as f: content = f.read() # Check for imports that might fail problem_imports = [ ("from pathlib import Path", "Path imported but might not be used correctly"), ("import experimentP2L", "experimentP2L might not be in Python path"), ] for import_stmt, issue in problem_imports: if import_stmt in content and "try:" not in content[:content.index(import_stmt)+100]: line_num = content[:content.index(import_stmt)].count('\n') + 1 self.bugs.append(Bug( category=BugCategory.IMPORT_ERROR, severity=BugSeverity.HIGH, file_path=str(py_file), line_number=line_num, description=issue, suggested_fix="Wrap import in try-except block" )) except Exception as e: print(f" ️ Could not scan imports in {py_file}: {e}") def _detect_azure_config_issues(self): """Detect Azure configuration problems""" print(" → Checking Azure configuration...") # Check for Azure config files azure_files = list(self.root_dir.glob("azure_*.py")) for azure_file in azure_files: try: with open(azure_file, 'r', encoding='utf-8') as f: content = f.read() # Check for missing error handling in Azure operations if "BlobServiceClient" in content and "try:" not in content: self.bugs.append(Bug( category=BugCategory.AZURE_CONFIG, severity=BugSeverity.HIGH, file_path=str(azure_file), line_number=1, description="Azure Blob operations without error handling", suggested_fix="Wrap Azure operations in try-except blocks" )) # Check for hardcoded credentials (security issue) if re.search(r'["\'][A-Za-z0-9+/=]{40,}["\']', content): self.bugs.append(Bug( category=BugCategory.AZURE_CONFIG, severity=BugSeverity.CRITICAL, file_path=str(azure_file), line_number=1, description="Possible hardcoded credentials detected", suggested_fix="Use Azure Key Vault or environment variables" )) except Exception as e: print(f" ️ Could not scan {azure_file}: {e}") def _detect_environment_issues(self): """Detect environment variable problems""" print(" → Checking environment issues...") for py_file in self.root_dir.rglob("*.py"): try: with open(py_file, 'r', encoding='utf-8') as f: lines = f.readlines() for i, line in enumerate(lines, 1): # Check for os.environ[] without .get() if re.search(r'os\.environ\[["\']', line) and ".get(" not in line: self.bugs.append(Bug( category=BugCategory.ENVIRONMENT, severity=BugSeverity.HIGH, file_path=str(py_file), line_number=i, description="Environment variable access without default value", suggested_fix="Use os.environ.get('VAR', 'default_value') instead" )) except Exception as e: print(f" ️ Could not scan {py_file}: {e}") def _detect_encoding_issues(self): """Detect file encoding problems""" print(" → Checking encoding issues...") for py_file in self.root_dir.rglob("*.py"): try: # Try to read with UTF-8 with open(py_file, 'r', encoding='utf-8') as f: content = f.read() # Check if file has BOM if content.startswith('\ufeff'): self.bugs.append(Bug( category=BugCategory.ENCODING, severity=BugSeverity.LOW, file_path=str(py_file), line_number=1, description="File contains UTF-8 BOM (can cause issues)", suggested_fix="Remove BOM from file" )) except UnicodeDecodeError: self.bugs.append(Bug( category=BugCategory.ENCODING, severity=BugSeverity.MEDIUM, file_path=str(py_file), line_number=1, description="File encoding is not UTF-8", suggested_fix="Convert file to UTF-8 encoding", auto_fixable=False )) # ============================================================================ # BUG FIXING SYSTEM # ============================================================================ class BugFixer: """Automatically fixes detected bugs""" def __init__(self, root_dir: str): self.root_dir = Path(root_dir) self.fixes_applied = 0 self.fixes_failed = 0 def fix_all(self, bugs: List[Bug]) -> Tuple[int, int]: """Fix all auto-fixable bugs""" print("\n Applying automatic fixes...") for bug in bugs: if bug.auto_fixable: try: if bug.category == BugCategory.PATH_ISSUE: self._fix_path_issue(bug) elif bug.category == BugCategory.IMPORT_ERROR: self._fix_import_error(bug) elif bug.category == BugCategory.ENVIRONMENT: self._fix_environment_issue(bug) elif bug.category == BugCategory.ENCODING: self._fix_encoding_issue(bug) self.fixes_applied += 1 print(f" Fixed: {bug.file_path}:{bug.line_number}") except Exception as e: self.fixes_failed += 1 print(f" Failed to fix {bug.file_path}:{bug.line_number}: {e}") else: print(f" ️ Skipped (manual fix required): {bug.file_path}:{bug.line_number}") return self.fixes_applied, self.fixes_failed def _fix_path_issue(self, bug: Bug): """Fix path-related bugs""" with open(bug.file_path, 'r', encoding='utf-8') as f: lines = f.readlines() line = lines[bug.line_number - 1] # Fix Path() / operator to os.path.join() if "Path(__file__).parent /" in line: # Extract the path parts match = re.search(r'Path\(__file__\)\.parent\s*/\s*"([^"]+)"', line) if match: path_part = match.group(1) fixed_line = line.replace( match.group(0), f'os.path.join(os.path.dirname(__file__), "{path_part}")' ) lines[bug.line_number - 1] = fixed_line # Fix .mkdir() to os.makedirs() with error handling if ".mkdir(" in line: indent = len(line) - len(line.lstrip()) var_match = re.search(r'(\w+)\.mkdir\(', line) if var_match: var_name = var_match.group(1) lines[bug.line_number - 1] = f"{' ' * indent}try:\n{line}{' ' * indent}except Exception as e:\n{' ' * indent} os.makedirs({var_name}, exist_ok=True)\n" with open(bug.file_path, 'w', encoding='utf-8') as f: f.writelines(lines) def _fix_import_error(self, bug: Bug): """Fix import errors by adding try-except""" with open(bug.file_path, 'r', encoding='utf-8') as f: lines = f.readlines() line = lines[bug.line_number - 1] indent = len(line) - len(line.lstrip()) # Wrap import in try-except import_stmt = line.strip() new_lines = [ f"{' ' * indent}try:\n", line, f"{' ' * indent}except ImportError as e:\n", f"{' ' * indent} print(f'Warning: {{e}}')\n", f"{' ' * indent} pass\n" ] lines[bug.line_number - 1:bug.line_number] = new_lines with open(bug.file_path, 'w', encoding='utf-8') as f: f.writelines(lines) def _fix_environment_issue(self, bug: Bug): """Fix environment variable access""" with open(bug.file_path, 'r', encoding='utf-8') as f: lines = f.readlines() line = lines[bug.line_number - 1] # Fix os.environ[] to os.environ.get() match = re.search(r'os\.environ\[["\']([^"\']+)["\']\]', line) if match: var_name = match.group(1) fixed_line = line.replace( match.group(0), f'os.environ.get("{var_name}", "")' ) lines[bug.line_number - 1] = fixed_line with open(bug.file_path, 'w', encoding='utf-8') as f: f.writelines(lines) def _fix_encoding_issue(self, bug: Bug): """Fix encoding issues""" if "BOM" in bug.description: with open(bug.file_path, 'r', encoding='utf-8-sig') as f: content = f.read() with open(bug.file_path, 'w', encoding='utf-8') as f: f.write(content) # ============================================================================ # COMPREHENSIVE SYSTEM CHECKER # ============================================================================ class SystemHealthChecker: """Check overall system health""" def __init__(self, root_dir: str): self.root_dir = Path(root_dir) def check_all(self) -> Dict: """Run all health checks""" print("\n Running system health checks...") results = { "python_version": self._check_python_version(), "dependencies": self._check_dependencies(), "azure_cli": self._check_azure_cli(), "directory_structure": self._check_directory_structure(), "config_files": self._check_config_files() } return results def _check_python_version(self) -> Dict: """Check Python version""" version = sys.version_info return { "version": f"{version.major}.{version.minor}.{version.micro}", "compatible": version.major == 3 and version.minor >= 8, "status": " " if version.major == 3 and version.minor >= 8 else " " } def _check_dependencies(self) -> Dict: """Check if required packages are installed""" required_packages = [ "flask", "flask-cors", "numpy", "azure-storage-blob", "azure-identity" ] installed = [] missing = [] for package in required_packages: try: __import__(package.replace("-", "_")) installed.append(package) except ImportError: missing.append(package) return { "installed": installed, "missing": missing, "status": " " if not missing else " " } def _check_azure_cli(self) -> Dict: """Check if Azure CLI is installed""" try: result = subprocess.run( ["az", "--version"], capture_output=True, text=True, timeout=5 ) return { "installed": result.returncode == 0, "version": result.stdout.split('\n')[0] if result.returncode == 0 else None, "status": " " if result.returncode == 0 else " " } except Exception: return { "installed": False, "version": None, "status": " " } def _check_directory_structure(self) -> Dict: """Check if required directories exist""" required_dirs = ["logs", "results", "tracking_data"] existing = [] missing = [] for dir_name in required_dirs: dir_path = self.root_dir / dir_name if dir_path.exists(): existing.append(dir_name) else: missing.append(dir_name) # Create missing directories try: try: dir_path.mkdir(parents=True, exist_ok=True) except Exception as e: os.makedirs(dir_path, exist_ok=True) print(f" Created missing directory: {dir_name}") except Exception as e: print(f" Failed to create {dir_name}: {e}") return { "existing": existing, "missing": missing, "status": " " # Always OK since we create missing dirs } def _check_config_files(self) -> Dict: """Check if required config files exist""" required_files = [ "requirements.txt", "azure_config.py", "life_backend_server.py" ] existing = [] missing = [] for file_name in required_files: file_path = self.root_dir / file_name if file_path.exists(): existing.append(file_name) else: missing.append(file_name) return { "existing": existing, "missing": missing, "status": " " if not missing else " ️" } # ============================================================================ # MAIN EXECUTION # ============================================================================ def print_bug_report(bugs: List[Bug]): """Print a formatted bug report""" print("\n" + "=" * 80) print(" BUG REPORT") print("=" * 80) # Group by severity by_severity = {} for bug in bugs: if bug.severity not in by_severity: by_severity[bug.severity] = [] by_severity[bug.severity].append(bug) for severity in [BugSeverity.CRITICAL, BugSeverity.HIGH, BugSeverity.MEDIUM, BugSeverity.LOW]: if severity in by_severity: print(f"\n {severity.value} - {len(by_severity[severity])} issues:") for bug in by_severity[severity]: print(f"\n [{bug.category.value}]") print(f" File: {bug.file_path}") print(f" Line: {bug.line_number}") print(f" Issue: {bug.description}") print(f" Fix: {bug.suggested_fix}") print(f" Auto-fixable: {'Yes' if bug.auto_fixable else 'No'}") def print_health_report(health: Dict): """Print a formatted health report""" print("\n" + "=" * 80) print(" SYSTEM HEALTH REPORT") print("=" * 80) for check_name, check_result in health.items(): print(f"\n{check_name.replace('_', ' ').title()}:") for key, value in check_result.items(): if key == "status": continue print(f" {key}: {value}") print(f" Status: {check_result.get('status', ' ')}") def main(): """Main execution""" print("=" * 80) print(" AZURE BUG ERADICATOR") print("=" * 80) print("Copyright 2025 - Sergio Paya Borrull") print("L.I.F.E. Platform Comprehensive Bug Fix System") print("=" * 80) # Get root directory root_dir = Path(__file__).parent print(f"\n Project directory: {root_dir}") # Step 1: Run system health checks health_checker = SystemHealthChecker(str(root_dir)) health = health_checker.check_all() print_health_report(health) # Step 2: Detect bugs detector = BugDetector(str(root_dir)) bugs = detector.scan_all() if not bugs: print("\n No bugs detected! Your system is healthy.") return print_bug_report(bugs) # Step 3: Ask user if they want to apply fixes print("\n" + "=" * 80) response = input("Would you like to apply automatic fixes? (yes/no): ").lower() if response in ['yes', 'y']: fixer = BugFixer(str(root_dir)) applied, failed = fixer.fix_all(bugs) print("\n" + "=" * 80) print(" FIX SUMMARY") print("=" * 80) print(f" Fixes applied: {applied}") print(f" Fixes failed: {failed}") print(f" ️ Manual fixes required: {sum(1 for b in bugs if not b.auto_fixable)}") if applied > 0: print("\n Bugs have been fixed! Please test your application.") else: print("\n ️ Skipped automatic fixes. Review the bug report above.") # Step 4: Generate fix report report_path = root_dir / "BUG_FIX_REPORT.json" report_data = { "timestamp": str(subprocess.check_output(["powershell", "-Command", "Get-Date -Format 'yyyy-MM-dd HH:mm:ss'"], text=True).strip()), "total_bugs": len(bugs), "by_severity": { "critical": len([b for b in bugs if b.severity == BugSeverity.CRITICAL]), "high": len([b for b in bugs if b.severity == BugSeverity.HIGH]), "medium": len([b for b in bugs if b.severity == BugSeverity.MEDIUM]), "low": len([b for b in bugs if b.severity == BugSeverity.LOW]) }, "by_category": { cat.value: len([b for b in bugs if b.category == cat]) for cat in BugCategory }, "health_checks": health } with open(report_path, 'w', encoding='utf-8') as f: json.dump(report_data, f, indent=2) print(f"\n Detailed report saved to: {report_path}") print("\n Bug eradication process complete!") if __name__ == "__main__": try: main() except KeyboardInterrupt: print("\n\n ️ Process interrupted by user.") sys.exit(1) except Exception as e: print(f"\n Unexpected error: {e}") import traceback traceback.print_exc() sys.exit(1)